-- This file was generated by				
-- Qfsm Version 0.55					
-- (C) Stefan Duffner, Rainer Strobel, Aaron Erhardt			


-- Inputs:   rxd_rec   addr[3]   addr[2]   addr[1]   addr[0]   pm_checked
-- State/Output              en_addr_reg en_data_reg en_regfile_wr pm_control_changed
-- wait_for_addr_s           0           0           0             0                  
-- fetch_addr_s              1           0           0             0                  
-- wait_for_data_s           0           0           0             0                  
-- fetch_data_s              0           1           0             0                  
-- write_regfile_s           0           0           1             0                  
-- check_written_addr_s      0           0           0             0                  
-- pattern_control_changed_s 0           0           0             1                  

LIBRARY IEEE;

USE IEEE.std_logic_1164.ALL;

ENTITY serial_receiver_fsm IS
  PORT (clk: IN std_ulogic;
        rst_n: IN std_ulogic;
        rxd_rec: IN std_ulogic;
        addr: IN std_ulogic_vector(3 DOWNTO 0);
        pm_checked: IN std_ulogic;
        en_addr_reg: OUT std_ulogic;
        en_data_reg: OUT std_ulogic;
        en_regfile_wr: OUT std_ulogic;
        pm_control_changed: OUT std_ulogic);
END serial_receiver_fsm;

ARCHITECTURE behave OF serial_receiver_fsm IS

TYPE state_type IS (wait_for_addr_s, fetch_addr_s, wait_for_data_s, fetch_data_s, write_regfile_s, check_written_addr_s, pattern_control_changed_s);
SIGNAL next_state, current_state : state_type;

BEGIN
  state_register: PROCESS (rst_n, clk)
  BEGIN
    IF rst_n='0' THEN
      current_state <= wait_for_addr_s;
    ELSIF rising_edge(clk) THEN
      current_state <= next_state;
    END IF;
  END PROCESS;

  next_state_and_output_logic: PROCESS (current_state, rxd_rec, addr(3 DOWNTO 0), pm_checked)
    VARIABLE temp_input : std_ulogic_vector(5 DOWNTO 0);
    VARIABLE temp_output : std_ulogic_vector(3 DOWNTO 0);
  BEGIN
    temp_input := rxd_rec & addr(3) & addr(2) & addr(1) & addr(0) & pm_checked;
    CASE current_state IS
      WHEN wait_for_addr_s => temp_output := "0000";
        CASE temp_input IS
          WHEN "000000" | "010000" | "001000" | "000100" | "000010" | "000001" | "011000" | "010100" | "010010" | "010001" | "001100" | "001010" | "001001" | "000110" | "000101" | "000011" | "011100" | "011010" | "011001" | "010110" | "010101" | "010011" | "001110" | "001101" | "001011" | "000111" | "011110" | "011101" | "011011" | "010111" | "001111" | "011111" =>
            next_state <= wait_for_addr_s;
          WHEN "100000" | "110000" | "101000" | "100100" | "100010" | "100001" | "111000" | "110100" | "110010" | "110001" | "101100" | "101010" | "101001" | "100110" | "100101" | "100011" | "111100" | "111010" | "111001" | "110110" | "110101" | "110011" | "101110" | "101101" | "101011" | "100111" | "111110" | "111101" | "111011" | "110111" | "101111" | "111111" =>
            next_state <= fetch_addr_s;
          WHEN OTHERS => next_state <= current_state;
        END CASE;
      WHEN fetch_addr_s => temp_output := "1000";
        CASE temp_input IS
          WHEN "100000" | "110000" | "101000" | "100100" | "100010" | "100001" | "111000" | "110100" | "110010" | "110001" | "101100" | "101010" | "101001" | "100110" | "100101" | "100011" | "111100" | "111010" | "111001" | "110110" | "110101" | "110011" | "101110" | "101101" | "101011" | "100111" | "111110" | "111101" | "111011" | "110111" | "101111" | "111111" =>
            next_state <= fetch_addr_s;
          WHEN "000000" | "010000" | "001000" | "000100" | "000010" | "000001" | "011000" | "010100" | "010010" | "010001" | "001100" | "001010" | "001001" | "000110" | "000101" | "000011" | "011100" | "011010" | "011001" | "010110" | "010101" | "010011" | "001110" | "001101" | "001011" | "000111" | "011110" | "011101" | "011011" | "010111" | "001111" | "011111" =>
            next_state <= wait_for_data_s;
          WHEN OTHERS => next_state <= current_state;
        END CASE;
      WHEN wait_for_data_s => temp_output := "0000";
        CASE temp_input IS
          WHEN "000000" | "010000" | "001000" | "000100" | "000010" | "000001" | "011000" | "010100" | "010010" | "010001" | "001100" | "001010" | "001001" | "000110" | "000101" | "000011" | "011100" | "011010" | "011001" | "010110" | "010101" | "010011" | "001110" | "001101" | "001011" | "000111" | "011110" | "011101" | "011011" | "010111" | "001111" | "011111" =>
            next_state <= wait_for_data_s;
          WHEN "100000" | "110000" | "101000" | "100100" | "100010" | "100001" | "111000" | "110100" | "110010" | "110001" | "101100" | "101010" | "101001" | "100110" | "100101" | "100011" | "111100" | "111010" | "111001" | "110110" | "110101" | "110011" | "101110" | "101101" | "101011" | "100111" | "111110" | "111101" | "111011" | "110111" | "101111" | "111111" =>
            next_state <= fetch_data_s;
          WHEN OTHERS => next_state <= current_state;
        END CASE;
      WHEN fetch_data_s => temp_output := "0100";
        CASE temp_input IS
          WHEN "100000" | "110000" | "101000" | "100100" | "100010" | "100001" | "111000" | "110100" | "110010" | "110001" | "101100" | "101010" | "101001" | "100110" | "100101" | "100011" | "111100" | "111010" | "111001" | "110110" | "110101" | "110011" | "101110" | "101101" | "101011" | "100111" | "111110" | "111101" | "111011" | "110111" | "101111" | "111111" =>
            next_state <= fetch_data_s;
          WHEN "000000" | "010000" | "001000" | "000100" | "000010" | "000001" | "011000" | "010100" | "010010" | "010001" | "001100" | "001010" | "001001" | "000110" | "000101" | "000011" | "011100" | "011010" | "011001" | "010110" | "010101" | "010011" | "001110" | "001101" | "001011" | "000111" | "011110" | "011101" | "011011" | "010111" | "001111" | "011111" =>
            next_state <= write_regfile_s;
          WHEN OTHERS => next_state <= current_state;
        END CASE;
      WHEN write_regfile_s => temp_output := "0010";
        CASE temp_input IS
          WHEN "000000" | "100000" | "010000" | "001000" | "000100" | "000010" | "000001" | "110000" | "101000" | "100100" | "100010" | "100001" | "011000" | "010100" | "010010" | "010001" | "001100" | "001010" | "001001" | "000110" | "000101" | "000011" | "111000" | "110100" | "110010" | "110001" | "101100" | "101010" | "101001" | "100110" | "100101" | "100011" | "011100" | "011010" | "011001" | "010110" | "010101" | "010011" | "001110" | "001101" | "001011" | "000111" | "111100" | "111010" | "111001" | "110110" | "110101" | "110011" | "101110" | "101101" | "101011" | "100111" | "011110" | "011101" | "011011" | "010111" | "001111" | "111110" | "111101" | "111011" | "110111" | "101111" | "011111" | "111111" =>
            next_state <= check_written_addr_s;
          WHEN OTHERS => next_state <= current_state;
        END CASE;
      WHEN check_written_addr_s => temp_output := "0000";
        CASE temp_input IS
          WHEN "000000" | "000001" | "000010" | "000011" | "000100" | "000101" | "000110" | "000111" | "001000" | "001001" | "001010" | "001011" | "001100" | "001101" | "001110" | "001111" | "010000" | "010001" | "010010" | "010011" | "010100" | "010101" | "010110" | "010111" | "011000" | "011001" | "011010" | "011011" | "011100" | "011101" | "100000" | "100001" | "100010" | "100011" | "100100" | "100101" | "100110" | "100111" | "101000" | "101001" | "101010" | "101011" | "101100" | "101101" | "101110" | "101111" | "110000" | "110001" | "110010" | "110011" | "110100" | "110101" | "110110" | "110111" | "111000" | "111001" | "111010" | "111011" | "111100" | "111101" =>
            next_state <= wait_for_addr_s;
          WHEN "011110" | "111110" | "011111" | "111111" =>
            next_state <= pattern_control_changed_s;
          WHEN OTHERS => next_state <= current_state;
        END CASE;
      WHEN pattern_control_changed_s => temp_output := "0001";
        CASE temp_input IS
          WHEN "000001" | "100001" | "010001" | "001001" | "000101" | "000011" | "110001" | "101001" | "100101" | "100011" | "011001" | "010101" | "010011" | "001101" | "001011" | "000111" | "111001" | "110101" | "110011" | "101101" | "101011" | "100111" | "011101" | "011011" | "010111" | "001111" | "111101" | "111011" | "110111" | "101111" | "011111" | "111111" =>
            next_state <= wait_for_addr_s;
          WHEN "000000" | "100000" | "010000" | "001000" | "000100" | "000010" | "110000" | "101000" | "100100" | "100010" | "011000" | "010100" | "010010" | "001100" | "001010" | "000110" | "111000" | "110100" | "110010" | "101100" | "101010" | "100110" | "011100" | "011010" | "010110" | "001110" | "111100" | "111010" | "110110" | "101110" | "011110" | "111110" =>
            next_state <= pattern_control_changed_s;
          WHEN OTHERS => next_state <= current_state;
        END CASE;
      WHEN OTHERS => temp_output := (OTHERS =>'X');
      next_state <= wait_for_addr_s;
    END CASE;
    en_addr_reg <= temp_output(3);
    en_data_reg <= temp_output(2);
    en_regfile_wr <= temp_output(1);
    pm_control_changed <= temp_output(0);
  END PROCESS;

END behave;
