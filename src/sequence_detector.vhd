-- This file was generated by				
-- Qfsm Version 0.55					
-- (C) Stefan Duffner, Rainer Strobel, Aaron Erhardt			


-- Inputs:   ser_i
-- State/Output done_o
-- State_0      0      
-- State_1      0      
-- State_2      0      
-- State_3      1      

LIBRARY IEEE;

USE IEEE.std_logic_1164.ALL;

ENTITY sequence_detector IS
  PORT (clk: IN std_ulogic;
        rst_n: IN std_ulogic;
        ser_i: IN std_ulogic;
        done_o: OUT std_ulogic);
END sequence_detector;

ARCHITECTURE behave OF sequence_detector IS

TYPE state_type IS (State_0, State_1, State_2, State_3);
SIGNAL next_state, current_state : state_type;

BEGIN
  state_register: PROCESS (rst_n, clk)
  BEGIN
    IF rst_n='0' THEN
      current_state <= State_0;
    ELSIF rising_edge(clk) THEN
      current_state <= next_state;
    END IF;
  END PROCESS;

  next_state_and_output_logic: PROCESS (current_state, ser_i)
    VARIABLE temp_input : std_ulogic_vector(0 DOWNTO 0);
    VARIABLE temp_output : std_ulogic_vector(0 DOWNTO 0);
  BEGIN
    temp_input(0) := ser_i;
    CASE current_state IS
      WHEN State_0 => temp_output := "0";
        IF temp_input="1" THEN
          next_state <= State_1;
        ELSIF temp_input="0" THEN
          next_state <= State_0;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN State_1 => temp_output := "0";
        IF temp_input="0" THEN
          next_state <= State_2;
        ELSIF temp_input="1" THEN
          next_state <= State_1;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN State_2 => temp_output := "0";
        IF temp_input="1" THEN
          next_state <= State_3;
        ELSIF temp_input="0" THEN
          next_state <= State_0;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN State_3 => temp_output := "1";
        IF temp_input="0" THEN
          next_state <= State_0;
        ELSIF temp_input="1" THEN
          next_state <= State_1;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN OTHERS => temp_output := (OTHERS =>'X');
      next_state <= State_0;
    END CASE;
    done_o <= temp_output(0);
  END PROCESS;

END behave;
